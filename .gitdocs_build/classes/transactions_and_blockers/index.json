{"title":"Transactions_and_blockers","content":"# Transactions and Blockers\n\nThese are advanced functionality that should be used with extreme care. \n\nWhy?\n\nBecause they can paralyze your feedback streams and bring your store to a screeching halt.  \n\nSo if they're so dangerous why use them? because \n\n> DANGER IS MY LAST NAME! --- Carlos Danger\n\n## Transactions\n\nTransactions is probably not the best name for this behavior but its very close. Transactions\ntemporarily squelch messaging in streams while the transaction exists. what is NOT squelched\nare methods, value updates, etc. Because of this, transactions can snuff out a lot of transitional\nnoise as sub-methods, property updates, etc. occur in a Store or Stream, allowing a quick \n\"after I'm done\" update that broadcasts the effect of multiple actions ina a single swoop. \n\nThis is a good thing, when everything goes right. \n\nThe method handling of a Store is designed to be as error-proof as possible. That is why \nthere are four classes of methods:\n\n* **default** -- non-transactional, never throws\n* **throws** -- non-transactional, throws\n* **trans** -- transactional, never throws\n* **throws + trans** -- transactional, throws\n\nWhatever the variant, the design of the store is to trap the thrown error and to squelch \nthe transaction before passing on the error to the errors stream -- and possibly throw it. \n\nBUT CODE IS HARD.\n\nso if for some reason you suspect your transactions are choking:\n\n1. subscribe to `MyStream/MyStore._$transStream`\n2. watch to see if it stays in a non-zero state for too long\n3. If you want to be ham-handed just call `Stream/Store.flushTranses()`.\n4. `flushTranses()` returns any stalled transactions; these Message instances\n   should tell you which transactions are delaying your Store/Stream. \n   \n## Blockers: the ultimate cyberbully\n\nBlockers are total show-stoppers. They don't just delay notification; they disable all methods\nAND update messaging. In fact if a Store is blocked, its properties are also blocked. \n\nWHY DO THIS?\n\nBecause there are circumstances where you don't want your Store/Stream to update. \nThe built in time is when you are deriving values for virtual fields. Derivation is intended \nto be totally non-invasive and non-store-updating. So if the Store detects that a derivation is\ncalling methods or setting values, the setting and calling short circuits and throws an error. \n\nVirtual fields re-calculate every broadcast cycle. They are intended to be idempotent reflectors\nof the stores' values. A classic example would be the magnitude of a point or the sin of an angle. \nStore.value.virtual will be undefined while blockers are present. \n\nStore.my IS available to be used, as it is a proxy, by derivations, and will have a store.my.virtualValue;\nYou can even call one virtual field from another provided this doesn't generate circularity. \nHandily, when one virtual field blocks, it blocks itself from being re-called by any other virtuals (and throws),\npreventing circular paralysis (but throwing);"}
