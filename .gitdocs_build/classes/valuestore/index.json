{"title":"ValueStore","content":"### ValueStore\n `<= ValueStream`\n\nValueStreams are useful in their own right but ValueStores are the overarching\nproduct of LGE. A ValueStore is a set of streams and methods to update the streams.\n\nValueStores are themselves ValueStreams. \n\nThe children of ValueStreams are called \"properties\"; this is an OOP-ism. \n\n## constructor\n`(name: string, values?: {Object}, methods? {Object})`\n\nThe \"value\" of a store is the summary of all the key/value pairs of its children. \n \nThe streamed value of a store is *itself* that is emitted over and over to its subscribers\non changes to any of its child streams. \n\n*Constructor Arguments*:\n\n`values` can be used to seed properties. They can be name/value pairs\nor name/argument pairs if you want to add validators etc. to the properties. \n\n`methods` can be used to initialize methods. they are name/function pairs. \n\nFWIW I personally prefer currying construction of ValueStores but for those\nthat want to fully construct a store in the constructor these properties exist. \n\n## subscribe\n`(onChange, onError, onComplete)`\n\nunlike ValueStore subscriptions which return the updates to value onChange,\nstore subscriptions return itself repeatedly on changes to its properties. \nAlso all property errors are repeated to onError in the form:\n\n```\n{ \n    store: string, // name of this store\n    source: string, // name of the stream that had an error\n    error: Object, // JSON snapshot of the error message\n}\n```\n\n## METHODS \n\nMethods are the \"actions\" of a store. They allow you to write mutators\nthat can interact with the store. \n\nThese actions are *not* in any way like Redux methods; they are closer to \nan OOP Classes' methods. \n\nThe return value of a method is both *optional* and *ignored* by the store itself. \nMethods can be used to define derived values but are not used to update the store.\nThe only way to update the store (and trigger a subscription update) is to \nset a properties' value. This can be done *never*, *once* or *multiple times* by an action. \n\nMethods' first argument is the store itself. Any other called arguments are passed \nin after that. So, the `this` value is not useful (or a good idea) to refer to in the body of an action. \nthat being said, if the `bind` modifier is true the method will be bound to the store. \n\nMethods are synchronous *by default*. You can return a promise but the method is considered \ncomplete (and the transactionality closed) at the end of the synchronous execution of the method. \n\nBy default method errors are trapped and redirected to the errors stream. That can be *bad* if\nyou call several methods in a row and expect that they have done their business.\n\nFor that reason methods are given a set of behavior modifiers:\n\n### Method modifiers\n\n* `throws` re-throws any errors your function emits or emitted from th errors collection. \n  this should be \"all the errors\". \n* `trans` is not exactly what DB transactions are. Due to references and other things its really\n  not valid to be able to claim the ability to reset a store to a previous state. \n  What it does do is muffle any change emission that happens in its execution or in any sub-method call\n  executions until its completed. Note that \"completed\" is a synchronous concept; async\n  functions are not guaranteed to wait to complete before ending the transaction and allowing broadcasts;\n  in fact they are pretty much guaranteed to be impossible to externally freeze. (you can still\n  create transactions inside a method to control broadcast of an async method if you want.)\n* `bind` is for those for whom normal methods have gotten boring and who want to add a little\n  excitement in their code. Just kidding; it uses functional binding to make the \"this\" reference\n  equal to the store. Not advised, but available. \n  \nAll these switches can be used in any combination to alter application flow to \nthe way you want it to execute. \n\nAgain, all configuration options are optional. \n\n## addMethod\n`(name: string, fn: function, options?: {bind:bool, trans:bool, throws: bool})` (alias `method`)\n\nAdds a method to the store. is *not* idempotent; \nsuccessive attempts to redefine the same method throw errors.\n\n## .do[methodName]\n\nA proxy to all the methods BUT WAIT -- THERE's MORE! When you add a property to the ValueStore\nyou get free \"setter\" methods.\n\nFor instance if you add a \"count\" property you get the methods \"setCount(value)\" and\na throwable set, \"setCount_ot(value\" AT NO ADDITIONAL COST! \n\n```javascript\n\nconst counter = new ValueStore('counter', { count: [0  , 'number']});\n\ncounter.subscribe((vs) => console.log(vs.my.count));\n\ncounter.do.setCount(1);\ncounter.do.setCount_ot('doghnut');\n\n// '1'\n// (throws)\n```\n\n## PROPERTIES\n\nProperties are the value providers for the store. Each property is a ValueStream (see) and  contributes to the \ncollective value of the store. \n\n## setFilter\n`(name, filter): self`\n\nsets and overrides the filter for a particular property. \n\n## .value\n`{Object}`\n\na name/value snapshot of the properties' values. NOTE: this is \nmore expensive than using `#my` if you just want to get one or more \nproperties from a large component so prefer the latter when possible (and if proxies exist.);\n\n## my[propertyName]\n\n.my is a proxy that lets you tunnel and extract the current value of a/some proxies using a Proxy implementation. \nIt is far more efficient than `.values` in most scenarios; given that Proxy is only available in most scenarios. \n\n```javascript\n\nconst threeDcoord = new ValueStream('coord3d', {x: 0, y: 0, z: 0});\n\nconst {x, y, z} = threeDcoord.my;\n\nthreeDcoord.do.setX(10);\n\nconsole.log('x was', x, 'and is now', threeDcoord.my.x);\n\n// 'x was', 0, 'and is now', 10\n```\n\n## property \n`(name, value, fliter?)` (alias `.setStream`)\n\ndefines a property of the ValueStore. \nProperties cannot be redefined (throws error once a name is taken).\n\nThis method creates a ValueStream and attaches it to the streams collection. \n\n## VIRTUALS\n\nVirtuals are computed values that are derived from the store. They are only computed when retrieved. \nThe function that defines a virtual *cannot* change the store. a virtual can call another virtual; but \nany circular reference (a calls b which calls a) will throw an error. \n\nVirtuals, like property values, can be accessed off the `.my` proxy. \n\n```javascript\n\nconst coord = new ValueStore('coord2D', { x: 0, y: 0 }, {}, {\n  magnitude: (store) => {\n    return Math.sqrt(store.my.x ** 2 + store.my.y ** 2);\n  },\n});\n\ncoord.do.setX(10);\ncoord.do.setY(20);\nconsole.log('magnitude:', coord.my.magnitude)\n// 'magnitude:' 22.360679774997897\n\n```"}
