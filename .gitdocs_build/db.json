[{"url":"/","title":"LGE","breadcrumbs":[{"title":"LGE","url":"/"}],"content":"# Looking Glass Engine 3.2\n\nThis incarnation of the Looking Glass Engine with a simpler interface for change tracking. \nLooking Glass 3 has a lot of moving parts and it is harder than necessary next infer functionality from source.\n\n## Improvements in 3.2\n\n### Throwable methods\n\nLGE 3.2 uses proxies more than LGE 3 did. As well, LGE 3 \"swallowed\" validation errors silently*, which\nin some cases is good, but in other cases might not be the desired behavior. \n\nLGE 3.2 *does* swallow errors by default, but you can configure methods to throw upon errors if you wish,\ninterrupting process flow on bad actions. \n\n### Transactional methods and greater exposure of the Transaction token\n\nMethods can be made transactional; this was true in 3 but not emphasized. \n\nAlso you can create and dispose of transactional tokens as you wish to, for insatnce, make parts\nof your methods transactional. \n\n## Architectural changes\n\n### Messages\n\nLGE 3.2 uses a concept of Messages as a class structure that filters through the streams,\nwhether the update stream or the error stream. Even transactions are Messages. \nThis allows for a more consistent set of annotation when information comes back \nor is polled in the debugging context. \n\n## Division of concerns\n\nthe ValueStream's functionality is now broken into three classes:\n\n1. the `Value` class is a pure name-value pair\n2. the `ValueStream` is a pure single-value construct that has no concept of actions. \n    It exists purely next report and be subscribable next, the value of its single action. \n    It has transactional locking and validation.\n3. The `ValueStore` is a collection of ValueStream properties, with actions.\n\nRemoving the polymorphic nature of ValueStreams allows each class next describe and \nfocus on its specialized purpose. \n____________________\n\n (*) semi-slently - they did emit through the errors watcher but did not interrupt the flow of code."},{"url":"/about-us/","title":"About Us","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"About Us","url":"/about-us/"}],"content":"# About Us\n\nGitDocs was built by the good folks over here at [Timber](https://timber.io). You should check us out."},{"url":"/classes/validators/","title":"Validators","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"Classes"},{"title":"Validators","url":"/classes/validators/"}],"content":"# Validators\n\n`validators(name, fn, override = false)` is a registry for validation functions, There are a few \n\"starter\" validators for common tests. In earlier editions the entire is.js module\nwas used to handle named tests but the bundle size got so big, and validators \nis a stand-in for that. \n\nThere are a few pre-loaded tests:\n\n* 'string'\n* 'number'\n* 'nan'\n* 'integer'\n* 'array'\n* 'object'\n\nfor really basic type checking. Feel free to add your own. \n\nFair warning: validators will throw an error if you try to redefine a validator without\nthe third argument being true. \n\nvalidators curries if the second argument is present. so if it doesn't drive you nuts\nyou can call:\n\n```javascript\n\nvalidators('odd', (v) => ((v + 1) % 2)  ? 'value must be odd' : false)\n('even', (v) => v % 2 ? false : 'value must be even')\n('square', (v) => Math.sqrt(v) % 1 ? 'value must be a perfect square' : false);\n\n```\n\nThis is used in conjunction with defining properties or ValueStreams:\n\n```javascript\n\nconst coords = new ValueStream('coords')\n.property('x', 'number')\n.property('y', 'number')\n.property('z', 'number')\n\n```"},{"url":"/classes/value/","title":"Value","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"Classes"},{"title":"Value","url":"/classes/value/"}],"content":"# Value\n\nThe Value is a name-value pair. Its not particularly useful but it does isolate some of the fundamental\nproperties of the other classes into a basic subclass. \n\n* It has no children or default requirements/restrictions on its value. \n* It can have a filter to restrict input. \n* It cannot be updated externally. \n\nSetting the value to an invalid item will throw; and if this is true of the initial value,\n*creating* a Value with an invalid initial value (based on its validator) will throw. \n\nValue is *not* a stream: it is simply the core validation/value/name functionality underpinning\nthe other classes. \n\n## constructor\n`(name: string, value?, filter? : function)`\n\n## .name \n`{String`\nName must be a valid javascript property name. \n\n## .value\ncan be any type. note - if not initialized to a value, it is internally\nannotated with a symbol ABSENT. \n\n## .filter\ncan be:\n* absent/falsy; all values are acceptable\n* a string: name of a method registered in validators\n* an array of the above\n\nfunctional tests express errors - valid values require a falsy return. \nThe first argument to the function is the value. The second one is an array\nof results from previously returned errors if the filter is an array:\n\n```javascript\nfunction isOddNumber(n, errors) {\n    if (errors.length) {\n      return false; // don't test oddness if the value is not a number.\n    }\n    \n    if ((n + 1) % 2) {\n      return 'must be an odd number';\n    }\n    return false;\n}\n\nconst ss2 = new Value('oddNum', 1, ['number', isOddNumber]);\n```\n\nArray filters let you ensure type sanity before applying business logic, or to \ndevelop and mix a suite of validation computations. The logical union of an array\nof tests is AND as in, every test in the array must pass or the validation is \nconsidered a failure. Unlike javascript && logic, every test in the array is always\nprocessed regardless of the outcomes of the previous tests. \n\n## validate\n`(value = ABSENT singleError? = false)`\n\ntests a value against the filter. returns an array of errors - empty if valid. \nif singleError, returns the first error."},{"url":"/classes/valuestream/","title":"ValueStream","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"Classes"},{"title":"ValueStream","url":"/classes/valuestream/"}],"content":"#ValueStream\n `<= Value`\n\nValueStream is a streaming version of Value. \n\n* It has the same constructor (and as a child class, methods) as `Value`. \n* It is an Observable, with the rx.js subscribe method available\n* You can set its' value with `.next(value)`\n\n## next\n`(value, attrs?:Object) : Message | Error`\n\nUnlike Value, ValueStream has a public method to update errors.\n`next(value)` will return a string if the value fails validation, \nand will leave its value unchanged. \n\nIf you want to augment the message that next uses to transmit state \n(such as making it transactional with {trans: true) you can set an object parameter set for the \nsecond argument. \n\nIn extreme failures, a standard error will be emitted; it will still \nhave an `.error` property for consistency. \n\n## nextPromise\n`(value, attrs?:Object) : Message | Error`\n\nuses the async conventions to allow you to trigger a handler when the \nnext attempt fails. Generally this is because you attempted to assert an invalid value.\nnote, the change is still immediate/synchronous. \n\n## subscribe\n`(onChange, onError, onComplete)`\n\nThis is the Observable method; it follows `rx.js` conventions EXCEPT that onError\ngets more messages than is typical. the rx.js standard is that onError is, like a \nfailed promise, the death rattle of a stream; and gets zero or one messages. \n\nIn LGE ValueStreams emit to onError many times, \nincluding when you try to set a value to an invalid value. \n\nIt may be useful to actually use onError to change field \nvalues to the user-attempted values and display errors on validation failure. \nthis will create dissonance between the form displayed values and the stored values\nbut as this only exists prior to submission it might be a good convention to try out. \n\n## complete\n`()`\n\nthis is part of the Observable interfaces. It completes all subscriptions. `.next` \nat this point doesn't have any effects after completion. \n\n## .$requests\n`stream`\n\nordinarily an internal stream that channels all the Messages prior to any\nerror testing/changes. Useful for debugging."},{"url":"/classes/valuestore/","title":"ValueStore","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"Classes"},{"title":"ValueStore","url":"/classes/valuestore/"}],"content":"### ValueStore\n `<= ValueStream`\n\nValueStreams are useful in their own right but ValueStores are the overarching\nproduct of LGE. A ValueStore is a set of streams and methods to update the streams.\n\nValueStores are themselves ValueStreams. \n\nThe children of ValueStreams are called \"properties\"; this is an OOP-ism. \n\n## constructor\n`(name: string, values?: {Object}, methods? {Object})`\n\nThe \"value\" of a store is the summary of all the key/value pairs of its children. \n \nThe streamed value of a store is *itself* that is emitted over and over to its subscribers\non changes to any of its child streams. \n\n*Constructor Arguments*:\n\n`values` can be used to seed properties. They can be name/value pairs\nor name/argument pairs if you want to add validators etc. to the properties. \n\n`methods` can be used to initialize methods. they are name/function pairs. \n\nFWIW I personally prefer currying construction of ValueStores but for those\nthat want to fully construct a store in the constructor these properties exist. \n\n## subscribe\n`(onChange, onError, onComplete)`\n\nunlike ValueStore subscriptions which return the updates to value onChange,\nstore subscriptions return itself repeatedly on changes to its properties. \nAlso all property errors are repeated to onError in the form:\n\n```\n{ \n    store: string, // name of this store\n    source: string, // name of the stream that had an error\n    error: Object, // JSON snapshot of the error message\n}\n```\n\n## METHODS \n\nMethods are the \"actions\" of a store. They allow you to write mutators\nthat can interact with the store. \n\nThese actions are *not* in any way like Redux methods; they are closer to \nan OOP Classes' methods. \n\nThe return value of a method is both *optional* and *ignored* by the store itself. \nMethods can be used to define derived values but are not used to update the store.\nThe only way to update the store (and trigger a subscription update) is to \nset a properties' value. This can be done *never*, *once* or *multiple times* by an action. \n\nMethods' first argument is the store itself. Any other called arguments are passed \nin after that. So, the `this` value is not useful (or a good idea) to refer to in the body of an action. \nthat being said, if the `bind` modifier is true the method will be bound to the store. \n\nMethods are synchronous *by default*. You can return a promise but the method is considered \ncomplete (and the transactionality closed) at the end of the synchronous execution of the method. \n\nBy default method errors are trapped and redirected to the errors stream. That can be *bad* if\nyou call several methods in a row and expect that they have done their business.\n\nFor that reason methods are given a set of behavior modifiers:\n\n### Method modifiers\n\n* `throws` re-throws any errors your function emits or emitted from th errors collection. \n  this should be \"all the errors\". \n* `trans` is not exactly what DB transactions are. Due to references and other things its really\n  not valid to be able to claim the ability to reset a store to a previous state. \n  What it does do is muffle any change emission that happens in its execution or in any sub-method call\n  executions until its completed. Note that \"completed\" is a synchronous concept; async\n  functions are not guaranteed to wait to complete before ending the transaction and allowing broadcasts;\n  in fact they are pretty much guaranteed to be impossible to externally freeze. (you can still\n  create transactions inside a method to control broadcast of an async method if you want.)\n* `bind` is for those for whom normal methods have gotten boring and who want to add a little\n  excitement in their code. Just kidding; it uses functional binding to make the \"this\" reference\n  equal to the store. Not advised, but available. \n  \nAll these switches can be used in any combination to alter application flow to \nthe way you want it to execute. \n\nAgain, all configuration options are optional. \n\n## addMethod\n`(name: string, fn: function, options?: {bind:bool, trans:bool, throws: bool})` (alias `method`)\n\nAdds a method to the store. is *not* idempotent; \nsuccessive attempts to redefine the same method throw errors.\n\n## .do[methodName]\n\nA proxy to all the methods BUT WAIT -- THERE's MORE! When you add a property to the ValueStore\nyou get free \"setter\" methods.\n\nFor instance if you add a \"count\" property you get the methods \"setCount(value)\" and\na throwable set, \"setCount_ot(value\" AT NO ADDITIONAL COST! \n\n```javascript\n\nconst counter = new ValueStore('counter', { count: [0  , 'number']});\n\ncounter.subscribe((vs) => console.log(vs.my.count));\n\ncounter.do.setCount(1);\ncounter.do.setCount_ot('doghnut');\n\n// '1'\n// (throws)\n```\n\n## PROPERTIES\n\nProperties are the value providers for the store. Each property is a ValueStream (see) and  contributes to the \ncollective value of the store. \n\n## setFilter\n`(name, filter): self`\n\nsets and overrides the filter for a particular property. \n\n## .value\n`{Object}`\n\na name/value snapshot of the properties' values. NOTE: this is \nmore expensive than using `#my` if you just want to get one or more \nproperties from a large component so prefer the latter when possible (and if proxies exist.);\n\n## my[propertyName]\n\n.my is a proxy that lets you tunnel and extract the current value of a/some proxies using a Proxy implementation. \nIt is far more efficient than `.values` in most scenarios; given that Proxy is only available in most scenarios. \n\n```javascript\n\nconst threeDcoord = new ValueStream('coord3d', {x: 0, y: 0, z: 0});\n\nconst {x, y, z} = threeDcoord.my;\n\nthreeDcoord.do.setX(10);\n\nconsole.log('x was', x, 'and is now', threeDcoord.my.x);\n\n// 'x was', 0, 'and is now', 10\n```\n\n## property \n`(name, value, fliter?)` (alias `.setStream`)\n\ndefines a property of the ValueStore. \nProperties cannot be redefined (throws error once a name is taken).\n\nThis method creates a ValueStream and attaches it to the streams collection."},{"url":"/getting-started/","title":"Getting Started","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"Getting Started","url":"/getting-started/"}],"content":"# Getting Started\n\nHere are some instructions on how to get started with our thing."},{"url":"/about-us/work-with-us/","title":"Work With Us","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"About Us","url":"/about-us/"},{"title":"Work With Us","url":"/about-us/work-with-us/"}],"content":"# Work With Us\n\nWant to build cool things? [Timber Careers](https://timber.io/about)"},{"url":"/getting-started/installation/","title":"Installation","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"Getting Started","url":"/getting-started/"},{"title":"Installation","url":"/getting-started/installation/"}],"content":"# Installation\n\nHere are some installation instructions for our thing."},{"url":"/getting-started/troubleshooting/","title":"Troubleshooting","breadcrumbs":[{"title":"LGE","url":"/"},{"title":"Getting Started","url":"/getting-started/"},{"title":"Troubleshooting","url":"/getting-started/troubleshooting/"}],"content":"# Troubleshooting\n\nHaving problems with the thing? Deal with them yourself."}]
