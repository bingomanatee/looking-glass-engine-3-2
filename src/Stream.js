import {
  map,
  distinctUntilChanged,
  switchMap,
  catchError,
  filter,
} from 'rxjs/operators';
import {
  BehaviorSubject, Subject, of, combineLatest,
} from 'rxjs';
import { proppify } from '@wonderlandlabs/propper';

import val, {
  isFunction, isObject, isArray,
} from './validators';
import { ID, ABSENT, isAbsent } from './absent';
import Change from './Change';

/**
 * This decorates and expands a value (standard) Subject
 * into its value along with metadata generated by its value.
 * It expresses the value,
 * the last valid value (that did not generate metadata)
 * the meta of the current value.
 *
 * it can optionally have a preprocessing filter that sanitizes values before they are
 * expressed as the next value, to for instance destructure arrays & objects into new references;
 */

export default class Stream {
  /**
   * @param store {ValueStore}
   * @param name {String}
   * @param initialValue any
   * @param pre {function | falsy} an optional function to pre-transform input
   * @param post {function | falsy} an optional function to note errors / annotation of value
   * @param comparator {function | false | null} an optional function to determine uniqueness
   */
  constructor(store, name, initialValue = null, pre = null, post = null, comparator = null) {
    this._value = initialValue;
    this.store = store;
    this.name = name;
    if (isObject(pre)) {
      const {
        pre: oPre, post: oPost, comparator: oComp,
      } = pre;
      this._pre = oPre;
      this._post = oPost;
      this._comparator = oComp;
    } else {
      this._pre = pre;
      this._post = post;
      this._comparator = comparator;
    }
    this._initSubject(initialValue);
    this._initialized = true;
  }

  _initSubject(initialValue) {
    this._subject = new BehaviorSubject(initialValue)
      .pipe(distinctUntilChanged((...args) => this._compare(...args)));

    this._subject.subscribe(value => this._value = value);
  }

  reset() {
    this.errors = [];
    this.thrown = [];
    this.notes = null;
  }

  _initChangeSubject() {
    this._changeSubject = new Subject()
      .pipe(
        switchMap(
          (newValue) => of(newValue)
            .pipe(
              map((value) => {
                const change = new Change(this, value);
                change.pre();
                return change;
              }),
              catchError(() => of(ABSENT)),
            ),
        ),
        switchMap(
          (newValue) => of(newValue)
            .pipe(
              map((change) => {
                change.post();
                return change;
              }),
              catchError(() => of(ABSENT)),
            ),
        ),
        filter((change) => !isAbsent(change)),
      );
    this._changeSubject.subscribe((change) => {
      if (!change.thrown.length) this._subject.next(change.nextValue);
    });
  }

  get changeSubject() {
    if (!this._changeSubject) {
      this._initChangeSubject();
    }
    return this._changeSubject;
  }

  pre(fn) {
    this._pre = fn;
    if (this._initialized) this.force();
  }

  post(fn) {
    this._post = fn;
    if (this._initialized) this.force();
  }

  force() {
    this.__forceUpdate = true;
    this.next(this.value);
  }

  _compare(a, b) {
    if (this.__forceUpdate || (this._comparator === false)) return false;
    if (isFunction(this._comparator)) return this._comparator(a, b);
    return a === b;
  }

  comparator(f) {
    this._comparator = f;
    return this;
  }

  /**
   * this is a magic property -- accessing it once will set it to false
   * -- but its previous current value will be returned.
   *
   * @returns {boolean}
   * @private
   */
  get __forceUpate() {
    const out = !!this.___forceUpdate;
    this.___forceUpdate = false;

    return out;
  }

  set __forceUpdate(v) {
    this.___forceUpdate = !!v;
  }

  get subject() {
    return this._subject;
  }

  subscribe(...methods) {
    this.subject.subscribe(...methods);
  }

  accepts(value) {
    try {
      this.getPost(value);
      return true;
    } catch (err) {
      return false;
    }
  }

  next(value) {
    this.changeSubject.next(value);
  }

  complete() {
    this._subject.complete();
    if (this._changeSubject) this._changeSubject.complete();
  }

  get value() {
    return this._value;
  }

  getPre(value) {
    if (isFunction(this._pre)) return this._pre(value);
    return value;
  }

  getPost(value) {
    const meta = {
      errors: [], notes: null,
    };
    if (isFunction(this._post)) {
      const post = this._post(value);
      if (post && isObject(post)) {
        if (isArray(post)) {
          meta.errors = post;
        } else Object.assign(meta, post);
      }
    }
    return meta;
  }

  get meta() {
    return {
      value: this.value,
      errors: [...this.errors],
      notes: this.notes,
      hasErrors: this.errors.length,
    };
  }
}

proppify(Stream)
  .addProp('errors', () => ([]), 'array')
  .addProp('thrown', () => ([]), 'array')
  .addProp('_comparator', null)
  .addProp('type', '', 'string')
  .addProp('notes', null);
