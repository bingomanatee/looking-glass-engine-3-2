import {
  map,
  distinctUntilChanged,
} from 'rxjs/operators';
import { BehaviorSubject } from 'rxjs';
import MetaList from './MetaList';
import Meta from './Meta';
import val, {
  isArray, isMap, isFunction, isNumber, isObject, isSet, isString,
} from './validators';
import { ID } from './absent';

const PREPROCESSORS = {
  array: (value) => (value && isArray(value) ? [...value] : []),
  object: (value) => (value && isObject(value) ? { ...value } : {}),
  string: (value) => ((isString(value)) ? value : ''),
  number: (value) => (isNumber(value) ? value : 0),
  map: (value) => (isMap(value) ? new Map(value) : new Map()),
  set: (value) => ((isSet(value)) ? new Set(value) : new Set()),
  function: (value) => (isFunction(value) ? value : ID),
};

/**
 * This decorates and expands a value (standard) Subject
 * into its value along with metadata generated by its value.
 * It expresses the value,
 * the last valid value (that did not generate metadata)
 * the meta of the current value.
 *
 * it can optionally have a preprocessing filter that sanitizes values before they are
 * expressed as the next value, to for instance destructure arrays & objects into new references;
 *
 * note - the heavy lifting for filters is done by _metaList. This class instance of MetaList
 * is omitted if there are no filters.
 */
export default class SubjectMeta {
  constructor(initialValue = null, meta) {
    this._initBase(initialValue);
    this._initMeta(initialValue, meta);
    this._initSubject();
  }

  get meta() {
    return this.getMeta(this.value);
  }

  preProcess(filter) {
    this._prep = false;
    const processor = filter || this._metaList.type;

    if (processor) {
      if (isString(processor)) {
        this._prep = PREPROCESSORS[processor];
      } else if (isFunction(processor)) {
        this._prep = processor;
      }
    }

    return this;
  }

  _initMeta(initialValue, filters) {
    this.lastValid = initialValue;
    if (!MetaList.hasMetas(filters)) {
      this._metaList = null;
      return;
    }
    this._metaList = new MetaList(filters);
    if (MetaList.errors(this.getMeta(initialValue))) {
      this.lastValid = undefined;
    }
  }

  getMeta(value) {
    return (this._metaList) ? this._metaList.getMeta(value, this) : [];
  }

  _initSubject() {
    this._subject = this._base.pipe(
      distinctUntilChanged(this._compare.bind(this)),
      map((value) => {
        const meta = this.getMeta(value);
        if (!MetaList.errors(meta)) {
          this.lastValid = value;
        }
        return Object.assign([value, meta], { value, meta, lastValid: this.lastValid });
      }),
    );
  }

  _compare(a, b) {
    return this.__forceUpdate ? false : a === b;
  }

  get value() {
    return this._value;
  }

  _initBase(initialValue) {
    this._value = initialValue;
    this._base = new BehaviorSubject(initialValue);
    this._base.subscribe((v) => {
      this._value = v;
    });
  }

  addMeta(...params) {
    const meta = new Meta(...params);
    if (!this._metaList) {
      this._metaList = new MetaList(meta);
    } else {
      this._metaList.add(meta);
    }
    this.force();
  }

  force() {
    this.__forceUpdate = true;
    this.next(this.value);
    this.__forceUpdate = false;
  }

  /**
   * this is a magic property -- accessing it once will set it to false
   * -- but its previous current value will be returned.
   *
   * @returns {boolean}
   * @private
   */
  get __forceUpate() {
    const out = !!this.___forceUpdate;
    this.___forceUpdate = false;

    return out;
  }

  set __forceUpdate(v) {
    this.___forceUpdate = !!v;
  }

  get subject() {
    return this._subject;
  }

  subscribe(...methods) {
    this._subject.subscribe(...methods);
  }

  next(value) {
    const nextValue = this._prep ? this._prep(value, this.getMeta(value), this) : value;
    this._base.next(nextValue);
  }

  complete() {
    this._base.complete();
  }
}
