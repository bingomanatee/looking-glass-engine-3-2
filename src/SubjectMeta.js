import {
  map,
  distinctUntilChanged,
} from 'rxjs/operators';
import { BehaviorSubject } from 'rxjs';
import MetaList from './MetaList';
import Meta from './Meta';
import val, {
  isArray, isMap, isFunction, isNumber, isObject, isSet, isString,
} from './validators';
import { NOOP } from './absent';

const PREPROCESSORS = {
  array: (value) => (value && isArray(value) ? [...value] : []),
  object: (value) => (value && isObject(value) ? { ...value } : {}),
  number: (value) => (isNumber(value) ? value : 0),
  map: (value) => (isMap(value) ? new Map(value) : new Map()),
  set: (value) => ((isSet(value)) ? new Set(value) : new Set()),
  function: (value) => (isFunction(value) ? value : NOOP),
};

/**
 * This decorates and expands a value (standard) Subject
 * into its value along with metadata generated by its value.
 * It expresses the value,
 * the last valid value (that did not generate metadata)
 * the meta of the current value.
 *
 * it can optionally have a preprocessing filter that sanitizes values before they are
 * expressed as the next value, to for instance destructure arrays & objects into new references;
 *
 */
export default class SubjectMeta {
  constructor(initialValue = null, meta) {
    this._initBase(initialValue);
    this._initMeta(initialValue, meta);
    this._initSubject();
  }

  get meta() {
    return this._metaList.annotate(this.value);
  }

  preProcess(filter) {
    const processor = filter || this._metaList.type;
    this._prep = false;
    if (processor) {
      if (isString(processor)) {
        this._prep = PREPROCESSORS[processor];
      } else if (isFunction(processor)) {
        this._prep = processor;
      }
    }

    return this;
  }

  _initMeta(initialValue, filters) {
    this._metaList = new MetaList(filters);
    this.lastValid = this._metaList.annotate(initialValue, this).length ? undefined : initialValue;
  }

  _initSubject() {
    this._subject = this._base.pipe(
      map((value) => {
        const meta = this._metaList.annotate(value, this);
        if (!meta.length) {
          this.lastValid = value;
        }
        return { value, meta, lastValid: this.lastValid };
      }),
    );
  }

  _initBase(initialValue) {
    this.value = initialValue;
    this._base = new BehaviorSubject(initialValue)
      .pipe(distinctUntilChanged());
    this._base.subscribe((v) => {
      this.value = v;
    });
  }

  addMeta(test, name = '', order = 1) {
    this._metaList.add(new Meta(test, name, order));
  }

  get subject() {
    return this._subject;
  }

  subscribe(...methods) {
    this._subject.subscribe(...methods);
  }

  next(value) {
    if (this._prep) this._base.next(this._prep(value));
    else this._base.next(value);
  }

  complete() {
    this._base.complete();
  }
}
